<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[洛谷题解-P2058-海港]]></title>
    <url>%2F2018%2F12%2F14%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-P2058-%E6%B5%B7%E6%B8%AF%2F</url>
    <content type="text"><![CDATA[LG - P2058 - 海港 题目这里 思路部分这道题乍一看是一道大难题大模拟 1 维护一个队列(不使用库函数) 叫做dl dl[i].ti意思是第i个人在什么时候到达 dl[i].ni意思是第i个人的国籍 2 输入国籍，定义pep,统计该国籍有没有人，如果没有那么ans++,并且pep[tmp]++; 3 由于给定条件保证数据递增,所以就保证此时的队列是一个单调递增的。然后定义e=0,这样从队头扫到元素时间与该此到达时间差小于86400（不等于）如果不满足则e++并且删掉一个改国籍的人,如果该国籍此时没有人那么ans–; 代码部分12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;struct node&#123; int ti,na;&#125;dl[400000];int ans=0;int pep[400000];int main()&#123; int n; cin&gt;&gt;n; int t,k,c=0; int e=1; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;t&gt;&gt;k; int tmp; for(int i=k;i&gt;=1;i--) &#123; cin&gt;&gt;tmp; dl[c+1].ti=t; dl[++c].na=tmp; if(!pep[tmp]) &#123; ans++; &#125; pep[tmp]++; &#125; while(t-dl[e].ti&gt;=86400) &#123; if(!--pep[dl[e++].na]) ans--; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 题解终于写完了]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flag?]]></title>
    <url>%2F2018%2F12%2F09%2Fflag%2F</url>
    <content type="text"><![CDATA[11.推出v0.3 未达成2.Ac 200道题 √ ff]]></content>
      <tags>
        <tag>flag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客更新说明]]></title>
    <url>%2F2018%2F12%2F08%2F%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[V0.1.0 2018.12.16 基础]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷题解-AT2281-Sum of Three Integers]]></title>
    <url>%2F2018%2F12%2F06%2F%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3-AT2281-Sum-of-Three-Integers%2F</url>
    <content type="text"><![CDATA[1234 嘿嘿嘿,做红题的感觉真不错 题目大意这道题就是求a+b+c=s有几种等式成立的可能性 0&lt;=a,b,c&lt;=k 给定s,k; 求出方案数. 思路暴力n^3对,看到是红题就认为暴力n^3能过，然后就凉了… 下面是代码 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main()&#123; int k,s; cin&gt;&gt;k&gt;&gt;s; int ans=0; for(int i=0;i&lt;=k;i++) &#123; for(int j=0;j&lt;=k;j++) &#123; for(int ij=0;ij&lt;=k;ij++) &#123; if(i+j+ij==s) &#123; ans++; &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; $n^2$算法em… 可以写两个循环求出第3个值。如果第三个值符合要求，则答案++,下面是AC代码 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int k,s; cin&gt;&gt;k&gt;&gt;s; int ans=0; for(int i=0;i&lt;=k;i++) &#123; for(int j=0;j&lt;=k;j++) &#123; int ij=s-i-j; if(ij&lt;=k &amp;&amp; ij &gt;=0)ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>洛谷题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP PJ 省一祭]]></title>
    <url>%2F2018%2F12%2F04%2FNOIP-PJ-%E7%9C%81%E4%B8%80%E7%A5%AD%2F</url>
    <content type="text"><![CDATA[1开心… NOIP 第一次参加就一等奖了198刚好蹭线 嘿嘿嘿]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解-NOIP2018T4对称二叉树]]></title>
    <url>%2F2018%2F12%2F01%2F%E9%A2%98%E8%A7%A3-NOIP2018T4%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[noip1=198…BJ蹭线 前言smallfang noip 考试失利所以得了198,感觉???? 题目应该都知道 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#define ull unsigned long longusing namespace std;int ans=1,n,v[1000005],l[1000005],r[10000005]; struct node&#123; int d; int t; int w; node(int da,int ta,int tw) &#123; d=da; t=ta; w=tw; &#125; bool operator==(const node&amp;b)const&#123;return d==b.d&amp;&amp;w==b.w&amp;&amp;t==b.t;&#125;&#125;; ull id(int x,int *l1,int *r1,ull h)&#123;if(l1[x]&gt;0) h=id(l1[x],l1,r1,h*1009+1); if(r1[x]&gt;0) h=id(r1[x],l1,r1,h*1009+2);return h*1009+v[x];&#125;node dfs(int x)&#123; if(x&lt;0)return node(0,0,0); node ll=dfs(l[x]); node rr=dfs(r[x]); if(ll==rr&amp;&amp;l[x]&gt;0&amp;&amp;id(l[x],l,r,0)==id(r[x],r,l,0)) ans=max(ans,2*ll.t+1); return node(max(ll.d,rr.d)+1,ll.t+rr.t+1,ll.w+rr.w+v[x]);&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)cin&gt;&gt;v[i]; for(int i=1;i&lt;=n;i++)cin&gt;&gt;l[i]&gt;&gt;r[i]; dfs(1); cout&lt;&lt;ans; return 0; &#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些备忘]]></title>
    <url>%2F2018%2F11%2F27%2F%E4%B8%80%E4%BA%9B%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[233…这里]]></content>
  </entry>
</search>
